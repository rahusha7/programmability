---
published: true
date: '2021-01-07 22:40 +0100'
title: pyATS series - Install and use pyATS
author: Antoine Orsoni
excerpt: Installation of pyATS and collecting your first CLI output
tags:
  - iosxr
  - cisco
  - pyATS
position: top
---
{% include toc icon="table" title="Table of Contents" %}
<head>
  <title></title>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <style type="text/css">
/*
generated by Pygments <https://pygments.org/>
Copyright 2006-2020 by the Pygments team.
Licensed under the BSD license, see LICENSE for details.
*/
pre { line-height: 125%; margin: 0; font-size: small; }
td.linenos pre { color: #000000; background-color: #f0f0f0; padding: 0 5px 0 5px; }
span.linenos { color: #000000; background-color: #f0f0f0; padding: 0 5px 0 5px; }
td.linenos pre.special { color: #000000; background-color: #ffffc0; padding: 0 5px 0 5px; }
span.linenos.special { color: #000000; background-color: #ffffc0; padding: 0 5px 0 5px; }
body .hll { background-color: #ffffcc }
body { background: #f8f8f8; }
body .c { color: #008800; font-style: italic } /* Comment */
body .err { border: 1px solid #FF0000 } /* Error */
body .k { color: #AA22FF; font-weight: bold } /* Keyword */
body .o { color: #666666 } /* Operator */
body .ch { color: #008800; font-style: italic } /* Comment.Hashbang */
body .cm { color: #008800; font-style: italic } /* Comment.Multiline */
body .cp { color: #008800 } /* Comment.Preproc */
body .cpf { color: #008800; font-style: italic } /* Comment.PreprocFile */
body .c1 { color: #008800; font-style: italic } /* Comment.Single */
body .cs { color: #008800; font-weight: bold } /* Comment.Special */
body .gd { color: #A00000 } /* Generic.Deleted */
body .ge { font-style: italic } /* Generic.Emph */
body .gr { color: #FF0000 } /* Generic.Error */
body .gh { color: #000080; font-weight: bold } /* Generic.Heading */
body .gi { color: #00A000 } /* Generic.Inserted */
body .go { color: #888888 } /* Generic.Output */
body .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
body .gs { font-weight: bold } /* Generic.Strong */
body .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
body .gt { color: #0044DD } /* Generic.Traceback */
body .kc { color: #AA22FF; font-weight: bold } /* Keyword.Constant */
body .kd { color: #AA22FF; font-weight: bold } /* Keyword.Declaration */
body .kn { color: #AA22FF; font-weight: bold } /* Keyword.Namespace */
body .kp { color: #AA22FF } /* Keyword.Pseudo */
body .kr { color: #AA22FF; font-weight: bold } /* Keyword.Reserved */
body .kt { color: #00BB00; font-weight: bold } /* Keyword.Type */
body .m { color: #666666 } /* Literal.Number */
body .s { color: #BB4444 } /* Literal.String */
body .na { color: #BB4444 } /* Name.Attribute */
body .nb { color: #AA22FF } /* Name.Builtin */
body .nc { color: #0000FF } /* Name.Class */
body .no { color: #880000 } /* Name.Constant */
body .nd { color: #AA22FF } /* Name.Decorator */
body .ni { color: #999999; font-weight: bold } /* Name.Entity */
body .ne { color: #D2413A; font-weight: bold } /* Name.Exception */
body .nf { color: #00A000 } /* Name.Function */
body .nl { color: #A0A000 } /* Name.Label */
body .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
body .nt { color: #008000; font-weight: bold } /* Name.Tag */
body .nv { color: #B8860B } /* Name.Variable */
body .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
body .w { color: #bbbbbb } /* Text.Whitespace */
body .mb { color: #666666 } /* Literal.Number.Bin */
body .mf { color: #666666 } /* Literal.Number.Float */
body .mh { color: #666666 } /* Literal.Number.Hex */
body .mi { color: #666666 } /* Literal.Number.Integer */
body .mo { color: #666666 } /* Literal.Number.Oct */
body .sa { color: #BB4444 } /* Literal.String.Affix */
body .sb { color: #BB4444 } /* Literal.String.Backtick */
body .sc { color: #BB4444 } /* Literal.String.Char */
body .dl { color: #BB4444 } /* Literal.String.Delimiter */
body .sd { color: #BB4444; font-style: italic } /* Literal.String.Doc */
body .s2 { color: #BB4444 } /* Literal.String.Double */
body .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
body .sh { color: #BB4444 } /* Literal.String.Heredoc */
body .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
body .sx { color: #008000 } /* Literal.String.Other */
body .sr { color: #BB6688 } /* Literal.String.Regex */
body .s1 { color: #BB4444 } /* Literal.String.Single */
body .ss { color: #B8860B } /* Literal.String.Symbol */
body .bp { color: #AA22FF } /* Name.Builtin.Pseudo */
body .fm { color: #00A000 } /* Name.Function.Magic */
body .vc { color: #B8860B } /* Name.Variable.Class */
body .vg { color: #B8860B } /* Name.Variable.Global */
body .vi { color: #B8860B } /* Name.Variable.Instance */
body .vm { color: #B8860B } /* Name.Variable.Magic */
body .il { color: #666666 } /* Literal.Number.Integer.Long */

  </style>
</head>
![pyats_hello2.jpg]({{site.baseurl}}/images/pyats_hello2.jpg){: .align-center}
# Introduction

Ever dreamed of a test framework that could be used across multiple platforms, OS and vendors, which could do regression, sanity and feature testing; already used by thousands of engineers and developers worldwide? Guess what, **it exists, it’s free, and you can start using it right now!**

pyATS (**Py**thon **A**utomated **T**est **S**ystems, to be pronounced "py A. T. S.") was first created as an internal project, to ease the validation of two OS versions. It has been made public in 2017 through **Cisco Devnet**.

This blog post will be the first one of a series on pyATS. Today, we will explain what’s pyATS, install pyATS and cover a basic use case (getting a CLI output from a XR device). More use cases are going to be covered in the next posts. 

The code used for each blog post can be found [here](https://github.com/AntoineOrsoni/xrdocs-how-to-pyats). This link will include the code for all posts.
{: .notice--info}

Today’s part will refer to the `0_get_cli_show` folder of the repo.

# Other pyATS episodes

You've missed an episode? You would like to read more? Below the list of published episodes:

| Episode 	| URL                                                                                              	| What's covered                                        	|
|---------	|--------------------------------------------------------------------------------------------------	|-------------------------------------------------------	|
| **1 - Install and use pyATS**       	| [Link](https://xrdocs.io/programmability/tutorials/pyats-series-install-and-use-pyats/){: .btn}  	|  What's pyATS, Install pyATS, Collect a raw CLI output 	|
| **2 - Parsing like  a pro**       	| [Link](https://xrdocs.io/programmability/tutorials/pyats-series-parsing-like-a-pro/){: .btn} 	|  Explore pyATS libraries, Collect and parse a CLI output        	|
| **3 - Be a model**       	| [Link](https://xrdocs.io/programmability/tutorials/pyats-series-be-a-model/){: .btn} 	|  What a pyATS model and when to use it        	|
| **4 - Collecting many show commands**       	| [Link](https://xrdocs.io/programmability/tutorials/pyats-series-collecting-many-show-commands/){: .btn} 	|  How to collect many show commands on many devices? |
| **5 - Tips and Tricks**       	| [Link](https://xrdocs.io/programmability/tutorials/pyats-series-tips-and-tricks/){: .btn} 	|  pyATS Tips and Tricks |
| **6 - Pushing and removing configuration**       	| [Link](https://xrdocs.io/programmability/tutorials/pyats-series-adding-and-removing-configuration/){: .btn} 	|  pyATS Tips and Tricks |


# pyATS overview

## Building blocks

pyATS is made of three main building blocks:
- **pyATS**, the core block of this ecosystem. It’s a Python framework which leverages multiple Python libraries such as [Unicon](https://pypi.org/project/unicon/), providing a simplified connection experience to network devices. It supports **CLI**, **NETCONF**, **RESTCONF** and **gRPC**. It enables network engineers and developers to start with small and simple test cases.
- **pyATS libraries** (also known as Genie) which provides everything you need for network testing such as parsers, triggers and APIs. 
- **XPRESSO**, the pyATS Web UI Dashboard.

You can read more about **pyATS ecosystem** in the [official documentation](https://pubhub.devnetcloud.com/media/pyats-getting-started/docs/intro/introduction.html).
{: .notice--info}

## Supported OS

This solution is built and thought from the ground up to be an **agnostic ecosystem**. As of January 2021, it comes out of the box with libraries for the below OS:

- IOS XR,
- IOS XE,
- IOS,
- NXOS,
- ASA,
- Linux,
- JUNOS,
- SROS,
- BIGIP,
- Viptela OS,
- DNA Center.

# Getting your hands dirty

Enough talking, do **YOU** want to start using pyATS? [Yes](){: .btn}

## pyATS requirements

Full requirements can be found in the [official documentation](https://pubhub.devnetcloud.com/media/pyats-getting-started/docs/prereqs/prerequisites.html).

### Hardware

pyATS is lightweight and scalable. As per the documentation, you need:
- 1GB of RAM,
- 1 vCPU.

### Operating System
 
It runs in a Linux and Linux-like environments, such as Ubuntu, CentOS, Fedora and macOS. 

The pyATS ecosystem does **not** support Windows.
{: .notice--warning}

### Python version

As of January 2021, it requires Python version between 3.5 and 3.8. 

Python version 3.9 is **not** yet supported.
{: .notice--warning}

![pyats_ready.png]({{site.baseurl}}/images/pyats_ready.png){: .align-center}

## pyATS installation

pyATS ecosystem can be installed in two ways: in a docker container or in a virtual environment. Today, we will focus on the second option. Remember, you need a Python version between 3.5 and 3.8 to use pyATS.

Full installation documentation for Docker and Virtual Environment can be found [here](https://pubhub.devnetcloud.com/media/pyats-getting-started/docs/install/installpyATS.html).

You don't have a supported system, but still want to run the code? Reserve the **Devnet DevBox**, [here](https://devnetsandbox.cisco.com/RM/Diagram/Index/f1a51f3b-3377-444d-97f0-5ad300d976be?diagramType=Topology), and start coding now!
{: .notice--info}

Let’s start! Open a bash terminal and run the below three commands. It will:
- Create a virtual environment.
- Activate the virtual environment.
- Install pyATS and its dependencies.

**From your bash terminal**
{: .notice--primary}
<div class="highlighter-rouge">
<pre class="highlight">
<code>
python -m venv venv
source venv/bin/activate
pip install pyats
</code>
</pre>
</div>

A **Python Virtual Environment** is a best pratice when you have different projects with different python module requirements. A Python Virtual Environment creates a folder (here, named `venv`) containing all the necessary executables and libraries for a project.

![venv.png]({{site.baseurl}}/images/venv.png)

## Your first pyATS use case: getting a CLI output from a device

In this first use case, we are going to see step by step how we can get a **simple CLI output** (`show ip interface brief`) from an IOS XR device. 

This first use case does **not** demonstrate the full power of pyATS but should be a good example to cover the basics.
{: .notice--info}

In order for everyone to be able to run the code, we will use the [IOS XR always-on sandbox on Cisco Devnet](https://devnetsandbox.cisco.com/RM/Diagram/Index/e83cfd31-ade3-4e15-91d6-3118b867a0dd?diagramType=Topology). Feel free to adapt the code to use your own device(s). Below the sandbox information.

| Key               	| Value                    	|
|-------------------	|--------------------------	|
| IOS XRv 9000 host 	| sbx-iosxr-mgmt.cisco.com 	|
|     SSH Port      	|     8181                 	|
|     Username      	|     admin                	|
|     Password      	|     C1sco12345           	|

## Building a testbed

The simplest way to connect to a device is through a pyATS testbed file, written in YAML. This information will be used by **Unicon** to connect to the device and send the requested commands.

You can find the complete documentation on how to build a testbed [here](https://pubhub.devnetcloud.com/media/unicon/docs/user_guide/connection.html).
{: .notice--info}

**testbed.yaml**
{: .notice--primary}
<div class="highlight"><pre><span></span><span class="c1"># Step 0: list of devices</span>
<span class="nt">devices</span><span class="p">:</span>
  <span class="nt">iosxr1</span><span class="p">:</span>
    <span class="c1"># Step 1: OS and Type</span>
    <span class="nt">type</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">iosxr-devnet</span>
    <span class="nt">os</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">iosxr</span>
    <span class="c1"># Step 2: credentials</span>
    <span class="nt">credentials</span><span class="p">:</span>
      <span class="nt">default</span><span class="p">:</span>
        <span class="nt">username</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">admin</span>
        <span class="nt">password</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">C1sco12345</span>
    <span class="c1"># Step 3: connection parameters</span>
    <span class="nt">connections</span><span class="p">:</span>
      <span class="nt">vty</span><span class="p">:</span>
        <span class="nt">protocol</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">ssh</span>
        <span class="nt">ip</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">sbx-iosxr-mgmt.cisco.com</span>
        <span class="nt">port</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">8181</span>
</pre></div>
{: .notice}

The `testbed.yaml` file is available [here](https://github.com/AntoineOrsoni/xrdocs-how-to-pyats/tree/master/0_get_cli_show).
{: .notice--info}

Let's now explain the building blocks of the testbed. The parts below will refer to each inline comment of the code block above.

### Step 0: list of devices

This line starts a **list of devices**. Here, I have one device: `iosxr1`. I could have many devices.

By default (i.e. if you does not change pyATS default settings), this name (`iosxr1`) will **need to exactly match the hostname of your device**. It is case sensitive.
{: .notice--warning}

If you do not want the device in your testbed to match the hostname, please refer to the documentation [here](https://pubhub.devnetcloud.com/media/unicon/docs/user_guide/connection.html), in the `learn_hostname` section.
{: .notice--info}

### Step 1: OS and type

**type** is mandatory, and is used for clarity (i.e. its value doesn’t matter).
**os** is the OS type of the device, as per the [Unicon documentation](https://pubhub.devnetcloud.com/media/unicon/docs/user_guide/supported_platforms.html).

### Step 2: credentials

**credentials** starts a list of credentials for this device. `username` and `password` are the credentials of your device.

`default` will be checked first, if not specified otherwise in your script.
{: .notice--info}


### Step 3: connection parameters

`connections` starts a list of possible connections for the device. If not specified otherwise, pyATS will try to use the `vty` connection. You need to specify a protocol, the ip of the device, and the port. 

You could add many more connections, such as **NETCONF** or **RESTCONF**. 
{: .notice--info}

Now that our testbed is ready, let’s make our **first** pyATS python script.

## Getting your first CLI output with pyATS

Let’s take a simple use case: we are going to connect to the device and collect a CLI output of the `show ip interface brief` command. This first example will not demonstrate the full power of pyAST but will be useful to understand its core functions. More to come in the next posts.

**0_execute_cli_show.py**
{: .notice--primary}
<div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pyats.topology</span> <span class="kn">import</span> <span class="n">loader</span>

<span class="c1"># Step 0: load the testbed</span>
<span class="n">testbed</span> <span class="o">=</span> <span class="n">loader</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;./testbed.yaml&#39;</span><span class="p">)</span>

<span class="c1"># Step 1: testbed is a dictionary. Extract the device iosxr1</span>
<span class="n">iosxr1</span> <span class="o">=</span> <span class="n">testbed</span><span class="o">.</span><span class="n">devices</span><span class="p">[</span><span class="s2">&quot;iosxr1&quot;</span><span class="p">]</span>

<span class="c1"># Step 2: Connect to the device</span>
<span class="n">iosxr1</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">init_exec_commands</span><span class="o">=</span><span class="p">[],</span> <span class="n">init_config_commands</span><span class="o">=</span><span class="p">[],</span> <span class="n">log_stdout</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

<span class="c1"># Step 3: saving the `show ip interface brief` output in a variable</span>
<span class="n">show_interface</span> <span class="o">=</span> <span class="n">iosxr1</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s1">&#39;show ip interface brief&#39;</span><span class="p">)</span>

<span class="c1"># Step 4: pritting the `show interface brief` output</span>
<span class="nb">print</span><span class="p">(</span><span class="n">show_interface</span><span class="p">)</span>

<span class="c1"># Step 5: disconnect from the device</span>
<span class="n">iosxr1</span><span class="o">.</span><span class="n">disconnect</span><span class="p">()</span>
</pre></div>

The `0_execute_cli_show.py` file is available [here](https://github.com/AntoineOrsoni/xrdocs-how-to-pyats/tree/master/0_get_cli_show).
{: .notice--info}

### Executing the script

**From your bash terminal**
{: .notice--primary}
<div class="highlighter-rouge">
<pre class="highlight">
<code>
python 0_execute_cli_show.py
</code>
</pre>
</div>

In this example, the `testbed.yaml` file need to be in the same folder as the `0_get_cli_show.py` file. Also, you need to execute the Python script in the folder where you have these two files.
{: .notice--info}

Let's now explain the building blocks of the Python script. The parts below will refer to each inline comment of the code block above.

### Output example

Here is an output example of the above script. It might slightly vary according to the configuration of the device.

**Python console**
{: .notice--primary}
<div class="highlighter-rouge">
<pre class="highlight">
<code>
Interface                      IP-Address      Status          Protocol Vrf-Name
Loopback100                    1.1.1.100       Up              Up       default 
Loopback200                    1.1.1.200       Up              Up       default 
Loopback999                    unassigned      Up              Up       default 
MgmtEth0/RP0/CPU0/0            10.10.20.175    Up              Up       default 
GigabitEthernet0/0/0/0         unassigned      Shutdown        Down     default 
GigabitEthernet0/0/0/1         unassigned      Shutdown        Down     default 
GigabitEthernet0/0/0/2         unassigned      Shutdown        Down     default 
GigabitEthernet0/0/0/3         unassigned      Shutdown        Down     default 
GigabitEthernet0/0/0/4         unassigned      Shutdown        Down     default 
GigabitEthernet0/0/0/5         unassigned      Shutdown        Down     default 
GigabitEthernet0/0/0/6         unassigned      Shutdown        Down     default
</code>
</pre>
</div>

### Step 0: load the testbed

From the `pyats.topology` module, we import the `loader()` function. This function will be used to load the testbed file we have created.

We load the `testbed` information, stored in our `testbed.yaml` file. We assign it to an object: `testbed`.

### Step 1: extract device information

`testbed` is a Python dictionary. We are extracting the device `iosxr1` information. We assign it to an object: `iosxr1`.

You can name the object with the name you want. The object name does not need to match the hostname of you device.
{: .notice--info}

### Step 2: connect to the device

We use the `connect()` method on the `iosxr1` object to connect to the device.

By default, pyATS will send exec and configuration commands to the device (such as `terminal length 0` and `show version`). To avoid such behavior, we are passing arguments to the `conect()` method. We are also disabling the logging to standard output.
More information in the [documentation].(https://pubhub.devnetcloud.com/media/unicon/docs/user_guide/connection.html)
{: .notice--info}

### Step 3: saving the CLI output

We send the command to the device with the `execute()` method. We save the output (a `string`) in a variable: `show_interface`.

Instead of `show ip interface brief`, you could send any command supported by your device.
{: .notice--info}

### Step 4: print the output

We `print` the output to the console.

### Step 5: disconnect from the device

We use the `disconnect()` method to properly disconnect from the device. 

It’s important to properly disconnect from the device, otherwise the vty connection will remain open on the device, until it times out.
{: .notice--info}

# Conclusion

In this first post of the pyATS series, we learnt how to build a `testbed` and how to collect our first CLI output from the device. In the next post, we will see how to parse the output to transform this big `string` into a `dictionary`.

The code used for each blog post can be found [here](https://github.com/AntoineOrsoni/xrdocs-how-to-pyats). This link will include the code for all posts.
{: .notice--info}

# Resources

Below a few useful pyATS resources.

- [The official pyATS documentation](https://pubhub.devnetcloud.com/media/pyats/docs/getting_started/index.html),
- [List of Unicon supported platforms](https://pubhub.devnetcloud.com/media/unicon/docs/user_guide/supported_platforms.html),
- [Devnet code exchange](https://developer.cisco.com/codeexchange/),
- [Join the Webex space with the pyATS community](https://eurl.io/#r18UzrQVr).
